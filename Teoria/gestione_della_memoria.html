<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gestione della memoria - Teoria</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-cc69e1fb.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-e787549c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-878570ab.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Teoria</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <script src="../javascript.js"></script>
<h1 id="gestione-della-memoria"><a class="header" href="#gestione-della-memoria">Gestione della memoria</a></h1>
<p>La <strong>memoria principale</strong> costituisce, insieme la CPU, una delle risorse per realizzare <strong>l’astrazione di processo</strong>.</p>
<p>Il processo dispone di una <strong>area di memoria</strong> ad esso <strong>riservata</strong> (non accessibile da altri processi).<br>Tale area di memoria (<em>memoria virtuale</em>) illude il processo facendogli credere di avere a disposizione <strong>l’intera memoria principale</strong>.</p>
<p>Questa memoria riservata permette a ciascun processo di avere una <strong>vista indipendente</strong> <strong>e continua</strong> della memoria, anche se, fisicamente, la memoria principale è condivisa tra più processi e l’allocazione dell’immagine di questi non è detto che sia continua.</p>
<p>Il sistema operativo, come per il processore, attraverso l’utilizzo dei <strong>PCB</strong> garantisce il principio di <strong>isolamento</strong> tra processi, ovvero è necessario assicurarsi che l’esecuzione di uno non interferisca con quella di un altro.<br>Quindi fisicamente i processi non devono accedere ad aree di memoria fisiche in cui è contenuta l’immagine di un altro processo.</p>
<p align="center"><img src="images/immagine_allocata_in_RAM.png" width="500"></p>

<p>L’immagine del processo è descritta all’interno del PCB dello specifico processo.<br>In questa struttura sono contenute anche informazioni <strong>su dove si trovano</strong> le diverse parti dell’immagine <strong>in memoria centrale</strong>.</p>
<p>I processi non accedono mai direttamente alla memoria principale tramite degli indirizzi.<br>Lavorano invece su una propria <strong>memoria virtuale</strong> (riservata), esso non utilizza indirizzi di memoria fisici ma bensì <strong>virtuali</strong>.</p>
<p>Tali <strong>indirizzi virtuali</strong> hanno senso solo nella visione della memoria del processo → non corrispondono a veri e propri indirizzi della memoria principale.</p>
<hr>
<p>ESEMPIO:</p>
<p>Quando utilizziamo indirizzi all’interno di un codice non stiamo realmente utilizzando indirizzi fisici ma indirizzi virtuali.</p>
<p>Infatti quando stampiamo gli indirizzi di memoria delle variabili che utilizza un processo non stiamo realmente stampando indirizzi di memoria, ma indirizzi di memoria logici.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
    int x = 3;
    printf("location of stack: %p\n", &amp;x);
    char * p = malloc(1024);
    printf("location of heap : %p\n", p);
    printf("location of code : %p\n", main);
}
</code></pre>
<pre><code class="language-console">location of stack: 0x7fff691aea64
location of heap : 0x1096008c0
location of code : 0x1095afe50
</code></pre>
<p>Tali indirizzi virtuali che abbiamo stampato vengono tradotti da un componente hardware (MMU - Memory Management Unit) per eseguire le istruzioni desiderate.</p>
<hr>
<p>Il kernel a differenza di un Hypervisor astrae l’hardware per consentire l’esecuzione di un processo in modo indipendente.</p>
<p>La posizione (<strong>indirizzi</strong>) di codice e dati nella memoria di un processo è un’<strong>astrazione</strong>. → indirizzi virtuali.</p>
<p>La posizione effettiva in memoria fisica è <strong>gestita dal sistema operativo</strong>.</p>
<h2 id="aspetti-e-parametri-caratterizzanti-la-gestione-della-memoria"><a class="header" href="#aspetti-e-parametri-caratterizzanti-la-gestione-della-memoria">Aspetti e parametri caratterizzanti la gestione della memoria</a></h2>
<ul>
<li>
<p><strong>Supporto Hardware</strong> per la gestione della memoria, in particolare l’isolamento tra i processi. (MMU)</p>
</li>
<li>
<p><strong>Organizzazione logica</strong> della memoria virtuale, ovvero le diverse sezioni che fanno parte della memoria virtuale di ogni processo.</p>
</li>
<li>
<p><strong>Organizzazione fisica</strong> della memoria principale, ovvero descrive come è allocata in memoria principale l’immagine di ogni singolo processo.</p>
<p>Tale organizzazione è necessaria per capire dall’indirizzo virtuale a quale indirizzo fisico si sta effettivamente accedendo.</p>
</li>
<li>
<p><strong>Dimensione della memoria virtuale</strong> che può essere più <strong>grande della memoria fisica disponibile</strong>.</p>
<p>Quindi il sistema operativo deve fare in modo di emulare la memoria fisica utilizzando la memoria secondaria, per permettere l’esecuzione dei processi che utilizzano più memoria di quanta ne sia disponibile.</p>
</li>
<li>
<p><strong>Rilocazione</strong>:</p>
<p>La rilocazione è un meccanismo che permette di caricare l’immagine di un processo in memoria principale.</p>
<p>Esistono due principali tipi di rilocazione:</p>
<ul>
<li>statica: gli indirizzi vengono definiti al momento della compilazione o caricamento del programma e non possono essere cambiati.</li>
<li>dinamica: gli indirizzi possono essere modificati durante l’esecuzione del programma, ad esempio quando il programma viene riattivato e ritorna nella memoria principale dallo swap.</li>
</ul>
</li>
<li>
<p><strong>Organizzazione dello spazio virtuale</strong></p>
<ul>
<li>spazio virtuale unico: tutta la memoria di un processo è trattata come un’unica area.</li>
<li>spazio virtuale segmentato: la memoria del processo è suddivisa in <strong>segmenti</strong> (ad esempio, codice, dati, stack) che vengono gestiti separatamente.</li>
</ul>
</li>
<li>
<p><strong>Allocazione</strong></p>
<p>Si riferisce alla maniera con cui il sistema operativo assegna la memoria principale ai processi.</p>
<ul>
<li>contigua: i dati di un processo sono collocati in un blocco contiguo di memoria.</li>
<li>non contigua: i dati di un processo possono essere sparsi in diverse aree della memoria, come avviene nella <strong>paginazione</strong>.</li>
</ul>
</li>
<li>
<p><strong>Caricamento</strong></p>
<p>Il caricamento riguarda come i processi vengono caricati in memoria:</p>
<ul>
<li>tutto insieme: il processo viene caricato tutto in una volta nella memoria.</li>
<li>a domanda: solo le parti del processo necessarie vengono caricate in memoria, quando l’esecuzione ne richiede l’accesso.</li>
</ul>
</li>
</ul>
<h2 id="tecniche-di-gestione-della-memoria"><a class="header" href="#tecniche-di-gestione-della-memoria">Tecniche di gestione della memoria</a></h2>
<hr>
<p>Rilocazione significa allocare l’immagine del processo nella memoria principale, può avvenire in diversi modi.</p>
<p>Questa rilocazione può essere statica o dinamica.</p>
<hr>
<p>Nei primi sistemi, il posizionamento del codice e dati è <strong>fisso</strong>. → con asim abbimo inserito in posizioni fisse il codice e i dati.<br>Il processo è caricato in RAM tutto insieme come un <strong>unico blocco</strong> (allocazione contigua).</p>
<p align="center"><img src="images/primi_sistemi_gestione_memoria.png" width="600"></p>

<p>Statica perché era più semplice.</p>
<p>Con l’introduzione di hw più evoluti si è permesso di configurare nella CPU il posizionamento di codice e dati, a <strong>tempo di esecuzione</strong>.<br>→ ad esempio sfruttando una base e un offset per determinare l’indirizzo fisico.</p>
<p>Con il supporto dei compilatori, la memoria del processo è divisa in blocchi (segmenti) che possono essere <strong>gestiti in maniera separata e indipendente dal SO</strong>.<br>Ad esempio il SO protegge il segmento dedicato al codice dando il permesso di sola lettura all’area di memoria a cui sarà destinato.</p>
<p align="center"><img src="images/evoluzione_hw.png" width="600"></p>

<p>Ulteriori evoluzioni hw hanno permesso di <strong>caricare</strong> l’immagine del processo (o un suo segmento) <strong>non più per intero</strong>, ma in <strong>piccole porzioni (pagine)</strong> ( caricamento a domanda) <strong>sparpagliate</strong> in memoria fisica (allocazione non contigua).</p>
<p>Quindi è stata introdotta l’allocazione di tipo <strong>non contigua</strong> grazie allo sviluppo dell’hardware MMU.</p>
<p>Che vantaggio mi da l’accolazione di tipo non contigua?<br>→ uso efficiente dell’area di memoria in termini di <strong>flessibilità e dinamicità</strong>; i processi non devono essere necessariamente allocati in un blocco contiguo di memoria.<br>→ attenua il <strong>problema della frammentazione</strong>, perché non ho bisogno di trovare una area di memoria di dimensione tale da contenere interamente l’immagine del processo. Ci sono due tipi principali di frammentazione:</p>
<ul>
<li>frammentazione interna: si verifica quando la memoria allocata per il processo <strong>è più grande di quella effettivamente necessaria</strong>.</li>
<li>frammentazione esterna: si verifica quando ci sono <strong>molti piccoli spazi liberi sparsi</strong> nella memoria fisica, ma <strong>nessuno</strong> di questi <strong>è abbastanza grande da ospitare un nuovo processo</strong>.</li>
</ul>
<p align="center"><img src="images/introduzione_MMU.png" width="600"></p>

<ul>
<li><strong>Partizioni fisse</strong>: memoria suddivisa in blocchi di <strong>dimensione fissa</strong>. Facile da gestire ma potrebbe causare <strong>frammentazione interna</strong>.</li>
<li><strong>Partizioni variabili</strong>: la memoria virtuale viene allocata in blocchi di <strong>dimensioni variabili</strong> a seconda delle necessità del processo. Riduce la frammentazione interna ma può comunque portare a <strong>frammentazione esterna</strong>.</li>
<li><strong>Partizioni multiple</strong>: una combinazione di partizioni fisse e variabili.</li>
<li><strong>Segmentazione a domanda</strong>: caricamento dinamico di segmenti di processi solo quando necessari. Ottimizza l’uso della memoria, ma può causare ritardi nei processi se la memoria virtuale deve essere frequentemente caricata dal disco.</li>
</ul>
<!-- @todo aggiungi paginazione e segmentazione con paginazione -->
<h2 id="rilocazione"><a class="header" href="#rilocazione">Rilocazione</a></h2>
<p>Modalità di allocazione dei dati e del codice di un processo in memoria fisica.</p>
<p>L’associazione di <strong>istruzioni e dati</strong> ad indirizzi di memoria (fisica) si può compiere in ognuna delle sequenti fasi:</p>
<ul>
<li>
<p><strong>compilazione</strong>: se nella fase di compilazione conosce dove il processo risiederà nella memoria, allora può <strong>inserire direttamente gli indirizzi fisici nel codice oggetto</strong>.</p>
<p>→ si genera così <strong>codice assoluto</strong>: gli indirizzi nel codice oggetto sono indirizzi fisici reali della RAM. Quindi codice e dati saranno allocati sempre in tali posizioni ad ogni esecuzione.</p>
<p>→ potrebbe essere un problema se il SO decidesse di caricare il programma in un’altra zona della memoria. Sarebbe necessaria una ricompilazione perché tutti gli indirizzi sarebbero <strong>sbagliati</strong>.</p>
<p>Quindi in questo caso gli indirizzi sarebbero fissati per sempre (fino ad una successiva ricompilazione)<br>→ nessuna <strong>flessibilità</strong>;</p>
</li>
<li>
<p><strong>caricamento</strong>: se nella fase di compilazione non è possibile sapere in che punto della memoria risiederà il processo, il compilatore deve generare <strong>codice rilocabile</strong>.</p>
<p>Quindi il <strong>compilatore</strong> <strong>non</strong> <strong>inserisce</strong> nel codice oggetto <strong>indirizzi fisici</strong> ma dei valori relativi che il loader dovrà sistemare.</p>
<p>Quando il processo viene caricato in memoria, il <strong>loader sceglie un indirizzo di partenza</strong> e scorre il codice oggetto aggiustando tutti gli altri indirizzi relativi.</p>
<p>→ dopo il caricamento, lo spazio di indirizzamento del processo non può più esser spostato, altrimenti andrebbero aggiornati tutti gli indirizzi fisici;</p>
</li>
<li>
<p><strong>esecuzione</strong>: se durante l’esecuzione il processo può essere spostato da un segmento di memoria ad un altro, è necessario che si ritardi l’associazione degli indirizzi fino alla fase di esecuzione. (rilocazione dinamica)</p>
<p>→ Qui entriamo in merito della <strong>memoria virtuale</strong> che permette al SO di:</p>
<ul>
<li>spostare un processo in RAM;</li>
<li>fare swapping su disco;</li>
<li>caricare pezzi di processo dove capita (dove si ha disponibilità) → utilizzo efficiente della memoria.</li>
</ul>
<p>Per permettere ciò <strong>non conviene</strong> fissare gli indirizzi fisici <strong>né a compilazione, né al caricamento</strong>.<br>Allora cosa accade:</p>
<ul>
<li>nel codice non vengono inseriti indirizzi fisici ma <strong>logici</strong>;</li>
<li>ogni volta che la CPU fa un accesso a memoria, interviene la <strong>MMU</strong> che traduce gli indirizzi logici nei corrispettivi indirizzi fisici a run-time.</li>
</ul>
<p>Se il processo viene spostato, basta cambiare il <strong>modo</strong> con cui la MMU traduce gli indirizzi.</p>
<p>Quindi per realizzare questo schema sono necessarie specifiche caratteristiche dell’architettura → MMU</p>
</li>
</ul>
<h3 id="statica"><a class="header" href="#statica">statica</a></h3>
<p>La rilocazione statica stabilisce gli indirizzi di codice e dati <strong>al momento della compilazione o caricamento</strong>.</p>
<p>La posizione del codice e dei dati <strong>non può più essere modificata</strong> a tempo di esecuzione.<br>→ nella programmazione in assembly si decide a priori dove il codice viene posizionato in memoria centrale.</p>
<p align="center"><img src="images/rilocazione_statica.png" width="550"></p>

<p>Il problema di questo tipo di rilocazione si presenta nel <strong>contex switch</strong>: il processo quando viene prelazionato e inserito nella coda dei processi pronti oppure swappato<br>→nel momento della sua successiva esecuzione deve trovarsi sempre nella stessa area di memoria, altrimenti tutti gli indirizzi fisici su cui lavora sarebbero sbagliati.<br>Questo è un grande <strong>onere computazionale</strong> affidato al sistema operativo.</p>
<p>Quindi con una rilocazione statica è il compilatore o il caricatore ad inserire degli indirizzi fisici all’interno rispettivamente del codice oggetto o del codice eseguibile.</p>
<p align="center"><img src="images/rilocazione_statica_1.png" width="600"></p>

<p>Questi indirizzi non potranno esser cambiato al meno che il codice non venga ricompilato oppure ricaricato.</p>
<h3 id="dinamica"><a class="header" href="#dinamica">dinamica</a></h3>
<p>Con questo approccio, dinamico, l’indirizzo di codice/dati nella immagine (<em>virtuale</em>) <strong>non corrisponde</strong> alla loro posizione effettiva in RAM (<em>indirizzo fisico</em>).</p>
<p>L’effettiva posizione dello spazio di indirizzamento del processo è <strong>scelta da SO</strong>, al caricamento iniziale del processo, o anche durante la sua esecuzione.</p>
<p>→ richiede un supporto hardware che permetta a tempo di esecuzione di tradurre gli indirizzi virtuali in indirizzi fisici.</p>
<p>Infatti la rilocazione di tipo dinamico si introduce un distinzione fondamentale:</p>
<ul>
<li>
<p><strong>Indirizzo virtuale</strong>:</p>
<p>indirizzo <strong>acceduto dal programma</strong> durante l’esecuzione.</p>
</li>
<li>
<p><strong>Indirizzo fisico</strong>:</p>
<p>indirizzo visto dall’unità di memoria, <strong>posizione effettiva</strong> del dato/istruzione.</p>
</li>
</ul>
<p>Quando otteniamo <strong>segmentation fault</strong> significa che l’indirizzo virtuale che stiamo utilizzando, erroneamente, non è associato ad un indirizzo fisico facente parte dell’immagine del processo nella memoria fisica → l’indirizzo fisico che stiamo deferenziando non è mappato nella memoria virtuale.<br>→ la traduzione da indirizzo virtuale a indirizzo fisico ha dato questo problema.</p>
<p>Vedremo che il fault può essere <strong>ripristinabile</strong>, perché il segmento/pagina non sono in memoria fisica ma sono swappati in memoria di massa. → ci troviamo nella situazione di un caricamento a domanda.</p>
<p>Il processore vede solo indirizzi logici (virtuali)<br>→ <strong>tradotti dall’hardware</strong> che ha la visibilità della memoria fisica, ovvero MMU.<br>MMU rende trasparente l’accesso del processore agli indirizzi fisici.</p>
<p>Se non fosse così il processore <strong>sarebbe più performante</strong> (vedrebbe direttamente gli indirizzi fisici), ma perderei tutta la parte di virtualizzazione.</p>
<p>Infatti come abbiamo visto, aprendo il file eseguibile od oggetto, non sono presenti indirizzi fisici ma unicamente indirizzi virtuali che solitamente partono tutti da <code>0x0</code>.</p>
<p align="center"><img src="images/rilocazione_dinamica.png" width="550"></p>

<h4 id="vantaggi-della-rilocazione-dinamica"><a class="header" href="#vantaggi-della-rilocazione-dinamica">Vantaggi della rilocazione dinamica</a></h4>
<p>La rilocazione dinamica consente lo <strong>swapping</strong></p>
<ul>
<li>un processo è temporaneamente <strong>sospeso</strong> e trasferito in <strong>memoria secondaria</strong>;</li>
<li>il processo potrà poi essere ri-caricato in un’<strong>area</strong> di <strong>memoria</strong> <strong>differente</strong>, in base alla situazione attuale della memoria.</li>
</ul>
<h4 id="mmu-memory-management-unit"><a class="header" href="#mmu-memory-management-unit">MMU (Memory Management Unit)</a></h4>
<p>MMU è un componente hardware della CPU che ha il compito di rendere <strong>trasparente l’accesso al processore</strong> alla memoria fisica tramite una traduzione di <strong>indirizzi virtuali</strong> (utilizzati dal processore) <strong>in indirizzi fisici</strong>.</p>
<p>ESEMPIO DI RILOCAZIONE DINAMICA:</p>
<p>Caso basilare (obsoleto):</p>
<ul>
<li>spazio virtuale unico → viene trattato come un unica area.</li>
<li>allocazione contigua → viene allocato in memoria tutto insieme.</li>
</ul>
<p>MMU in questo caso possiamo rappresentarla come un componente hardware avente due registri speciali: <strong>limite</strong> e <strong>base</strong>.</p>
<p>In questo caso banale la traduzione avviene con la somma tra l’indirizzo virtuale + la base, ovviamente a valle di una verifica sull’indirizzo virtuale (se esiste un indirizzo fisico mappato con tale indirizzo virtuale).</p>
<p align="center"><img src="images/caso_obsoleto.png" width="550"></p>

<p>Ovviamente dobbiamo prevedere un modo per modificare i registri dell’MMU, che sono specifici per ogni processo.</p>
<p>Oltre a cambiare valore per ogni processo i due registri devono esser modificati anche ogni volta che un processo passa in esecuzione da che era swappato<br>→ con la rilocazione dinamica potrebbe ritrovarsi in una posizione della memoria fisica differente alla precedente</p>
<p>Questo modello infatti non è la realtà, è uno schema di funzionamento base dell’MMU.</p>
<h2 id="caricamento-unico-e-a-domanda"><a class="header" href="#caricamento-unico-e-a-domanda">Caricamento unico e a domanda</a></h2>
<p>Il caricamento in memoria dell’immagine del processo è fatta dal <strong>loader</strong> che è parte del SO che:</p>
<ul>
<li><strong>legge</strong> l’eseguibile (e.g. ELF);</li>
<li><strong>alloca</strong> memoria per il processo;</li>
<li><strong>mappa</strong> gli indirizzi virtuali negli indirizzi fisici (a seconda della rilocazione utilizzata: statica o dinamica);</li>
<li><strong>copia</strong> in RAM le parti necessarie del programma (<strong>a seconda della tipologia di caricamento</strong>);</li>
<li><strong>prepara</strong> il processo per la prima esecuzione → ad esempio, crea il PCB.</li>
</ul>
<p>Nella fase di copia il loader si può comportare in due modi a seconda della tipologia di caricamento implementata:</p>
<ul>
<li>
<p>Nel <strong>caricamento unico</strong> (tutto insieme)</p>
<ul>
<li>Il loader carica tutta l’immagine del programma in memoria RAM.</li>
</ul>
<p>Questo è un approccio tipico dei vecchi sistemi o microcontrollori.</p>
</li>
<li>
<p>Nel <strong>caricamento a domanda</strong> (demand loading)</p>
<ul>
<li>Il loader crea solo le mappature virtuali → fisiche.</li>
<li>Il caricamento effettivo del codice/dati avviene <strong>solo quando necessario</strong>.</li>
<li>La MMU genera un fault quando la <strong>CPU tenta di accedere a una parte del processo che NON è ancora stata caricata in memoria fisica</strong>.</li>
</ul>
<p>A questa fault generata (<strong>interruzione sincrona</strong>), il SO chiama un handler che fa una recovery. Ovvero verifica se tale parte di processo a cui voule accedere la CPU è presente in memoria secondaria e la carica, permettendo al processore di proseguire con l’esecuzione.</p>
<p>Se tale parte non viene trovata viene rilanciata ancora la fault che in questo caso genera la terminazione del processo → ha tentato di accedere ad un indirizzo di memoria che non fa parte del proprio spazio di indirizzamento.</p>
<blockquote>
<p>NOTA: fault è un tipo di interruzione sincrona perché viene chiamata nel momento in cui nella tabella delle pagine o segmenti non è stata mappata la pagina virtuale in una fisica.
<strong>NON è asincrona</strong>.</p>
</blockquote>
</li>
</ul>
<h2 id="gestione-dello-spazio-virtuale"><a class="header" href="#gestione-dello-spazio-virtuale">Gestione dello spazio virtuale</a></h2>
<p>Vi sono due possibili approcci per gestire lo <strong>spazio virtuale</strong> degli indirizzi.</p>
<ul>
<li>Uno <strong>spazio unico</strong><br>(corrispondente all’intero processo)</li>
<li>Un insieme di <strong>segmenti</strong><br>(<strong>segmentazione</strong> → la memoria del processo è gestita in porzioni separate)</li>
</ul>
<p align="center"><img src="images/approcci_spazio_virtuale.png" width="500"></p>

<p>Nell’approccio segmentato l’immagine del processo è suddivisa in <strong>porzioni logiche</strong> (segmenti) gestite in modo separato ed indipendente dal sistema operativo.<br>Ogni segmento può avere una dimensione variabile, in base alla struttura logica del programma (codice, heap, stack, dati).</p>
<p><strong>Vantaggio principale</strong>:<br>La segmentazione facilita la condivisione di aree di memoria fisica tra più processi, mappandole in segmenti distinti del loro spazio di indirizzamento.\</p>
<ul>
<li>→ Esempio:<br>il segmento di codice (text) di un programma è di sola lettura.<br>Più processi che eseguono lo stesso programma possono <strong>condividere la stessa copia fisica</strong> del codice, mappandola nel proprio spazio di indirizzamento virtuale all’interno del segmento dedicato all’area testo.</li>
</ul>
<h2 id="segmentazione"><a class="header" href="#segmentazione">segmentazione</a></h2>
<div style="display: flex;">
<div>
A <b>tempo di compilazione</b>, si configura lo spazio virtuale segmentato.
<p>Viene creato un diverso <strong>segmento</strong> per ciascun <strong>modulo</strong> del programma.</p>
<hr>
<h4 id="vantaggi-della-segmentazione"><a class="header" href="#vantaggi-della-segmentazione">vantaggi della segmentazione</a></h4>
<ul>
<li><strong>Protezione</strong> dei segmenti;<br>permette una <strong>granularità fine</strong> nella gestione dei permessi sullo spazio di indirizzamento.<br>Ad ogni segmento può avere <strong>permessi diversi</strong> (lettura, scrittura, esecuzione).</li>
</ul>
</div>

<p align="center"><img src="images/segmenti_per_moduli.png" width="300"></p>

</div>

<ul>
<li>
<p><strong>Condivisione</strong> dei segmenti;<br>segmenti come <strong>codice</strong> (text) o le <strong>librerie</strong> <strong>condivise</strong> possono essere mappate da più processi e condividere un’unica copia fisica, <strong>riducendo l’uso della memoria</strong>.</p>
</li>
<li>
<p><strong>Allocazione indipendente</strong> dei segmenti in memoria fisica → riduce (ma non elimina) il problema della frammentazione.<br>Ogni segmento può essere <strong>collocato separatamente in punti diversi</strong> della memoria fisica.</p>
</li>
</ul>
<hr>
<p>Un indirizzo virtuale è una coppia (contiene due informazioni), fatta da:</p>
<ul>
<li>un <strong>identificativo</strong> del segmento;</li>
<li>uno <strong>scostamento</strong> (offset) all’interno del segmento.</li>
</ul>
<p align="center"><img src="images/info_indirizzi_virtuali.png" width="600"></p>

<p>L’<strong>MMU</strong> è il componente su cui si basa anche la segmentazione.</p>
<ul>
<li>Traduce gli indirizzi virtuali dalla forma (<em>segmento</em>, <em>offset</em>) in indirizzi fisici.</li>
<li>Nel caso di <strong>pochi segmenti</strong>, è sufficiente avere nella MMU più coppie di registri base/limite: uno per ogni segmento.</li>
</ul>
<p>Questo è un <strong>limite</strong> fisico importante perché non mi permetterebbe di avere molti segmenti. → non posso avere un numero infinito di registri.</p>
<hr>
<p>ESEMPIO SEGMENTAZIONE CASO SEMPLICE:</p>
<p align="center"><img src="images/MMU_multi_registro.png" width="500"></p>

<ul>
<li>in questo caso ogni coppia di registri corrisponde a limite e base per un segmento allocato in memoria fisica</li>
<li>l’identificativo <code>sg</code> servirà per capire a quale tipologia di segmento accedere facendo riferimento alla giusta coppia D, I</li>
<li>l’offset (<code>off</code>) sarà sommato al corretto registro base I se &lt;= del registro limite D corrispondente ad un segmento, altrimenti la MMU solleverà un eccezione (segmentation fault).</li>
</ul>
<hr>
<p>Nel caso <strong>generale</strong>, quando si vuole supportare un <strong>numero arbitrario di segmenti</strong>, non è possibile avere una coppia <strong>base/limite</strong> nella MMU per ogni segmento di un processo.</p>
<p>Per questo motivo:</p>
<ul>
<li>le coppie base/limite non risiedono nella MMU, ma sono memorizzare in <strong>memoria RAM</strong>;</li>
<li>queste informazioni sono raccolte in una struttura dedicata, chiamata <strong>tabella dei segmenti (segment table)</strong> unica <strong>per ogni processo</strong>;</li>
<li>ogni <strong>entry</strong> della tabella dei segmenti contiene i dati relativi a un <strong>segmento del processo</strong>: <strong>indirizzo base</strong>, <strong>limite</strong> e <strong>bit di controllo</strong> (permessi rwx).</li>
</ul>
<p>La MMU gestisce la segment table con due appositi <strong>registri</strong>:</p>
<ul>
<li><strong>STBR</strong> (Segment Table Base Register): indirizzo in memoria fisica in cui si trova la tabella dei segmenti.</li>
<li><strong>STLR</strong> (Segment Table Limit Register): dimensione della tabella dei segmenti (indica il <strong>numero di segmenti del processo</strong>)</li>
</ul>
<p>Il SO, all’atto del caricamento in memoria del processo da eseguire, imposterà l’<strong>indirizzo fisico</strong> dell’<em>entry point</em> della <em>segment table</em> nel registro <strong>STBR</strong>.<br>Tale indirizzo essendo strettamente legato al processo, è contenuto all’interno del PCB.</p>
<hr>
<p>ESEMPIO DI TRADUZIONE UTILIZZANDO LA SEGMENT TABLE:</p>
<p align="center"><img src="images/trad_segment_table.png" width="600"></p>

<ul>
<li><code>sg</code> è l’offset per identificare l’entry point relativo ad un segmento.</li>
<li>Per accedere alla tabella il processore utilizza le informazioni contenute in <code>STBR</code> e <code>STLR</code>  i cui valori sono contenuti all’interno del PCB di ogni processo.</li>
</ul>
<hr>
<p>NOTA sulla segment table:</p>
<ul>
<li>ogni processo ha una <strong>segment table differente</strong></li>
<li>i registri STBR/STLR sono configurati ad ogni <strong>contex switch</strong> dei processi<br>→ durante il contex switch il SO carica i valori di STBR/STLR dal <strong>PCB del processo</strong> (sono legati al singolo processo).</li>
</ul>
<p align="center"><img src="images/contex_ST.png" width="600"></p>

<h4 id="protezione"><a class="header" href="#protezione">protezione</a></h4>
<p>Ogni segmento può avere diversi <strong>permessi di accesso</strong> specificati da bit di controllo contenuti nella segment table.</p>
<ul>
<li>Ogni riga della segment table di un processo contiene per ogni entry anche una sequenza di <strong>bit di controllo</strong> per gestire i permessi sull’area di memoria in cui è mappato il segmento.</li>
<li>MMU produce una <strong>exception</strong> se il programma non rispetta i permessi.</li>
</ul>
<p align="center"><img src="images/entry_bit.png" width="400"></p>

<h4 id="condivisione"><a class="header" href="#condivisione">condivisione</a></h4>
<p>La segmentazione consente la <strong>condivisione dei segmenti</strong> tra più processi, allocando in memoria fisica una sola copia del segmento.</p>
<p>Abbiamo due processi con le rispettive tabelle dei segmenti.</p>
<p>→ Se hanno una entry in comune significa che i due processi possono accedere alla stessa area di memoria fisica.<br>Quindi stanno effettivamente condividendo la copia del segmento di memoria. Questo permette di allocare una sola copia del segmento in memoria.</p>
<p align="center"><img src="images/condivisione_segmento.png" width="500"></p>

<h4 id="allocazione"><a class="header" href="#allocazione">allocazione</a></h4>
<p>Uno spazio/segmento di memoria virtuale può essere <strong>collocato in memoria fisica</strong> in due possibili modi:</p>
<ul>
<li>
<p>allocazione <strong>contigua</strong>:</p>
<p>lo spazio/segmento è <strong>copiato per intero</strong>, in un intervallo di memoria fisica agli indirizzi [D;D+I]</p>
</li>
<li>
<p>allocazione <strong>non contigua</strong> (<strong>paginazione</strong>)</p>
</li>
</ul>
<h5 id="allocazione-contigua"><a class="header" href="#allocazione-contigua">allocazione contigua</a></h5>
<ul>
<li>
<p>Il SO colloca il proprio blocco di memoria virtuale, e quelli dei processi, in intervalli <strong>non-sovrapposti</strong> della memoria fisica</p>
</li>
<li>
<p>Quando un processo termina, la memoria fisica occupata si libera, creando un <strong>hole</strong></p>
</li>
<li>
<p>Quando un nuovo processo viene caricato, occorre <strong>cercare un hole sufficientemente grande</strong> da contenerlo</p>
<p>→ compito dello sheduler a medio termine.</p>
</li>
</ul>
<p align="center"><img src="images/allocazione_contigua.png" width="600"></p>

<p>Questo è un esempio su come facilmente si può arrivare ad un problema di <strong>frammentazione esterna</strong> della memoria.</p>
<p>Se ci sono <strong>più buchi liberi</strong>, ci sono vari criteri per scegliere dove collocare un segmento:</p>
<ul>
<li><strong>first-fit</strong>: si assegna il <strong>primo</strong> hole sufficientemente grande;</li>
<li><strong>best-fit</strong>: si assegna lo hole <strong>più piccolo</strong> tra quelli sufficientemente grandi per contenere lo spazio di indirizzamento del processo;</li>
<li><strong>worst fit</strong>: si assegna lo hole più grande.</li>
</ul>
<p>In generale, gli <strong>schemi a partizione di dimensione variabile</strong> soffrono del problema della frammentazione esterna.</p>
<p><strong>Frammentazione esterna</strong>: spazio di memoria perduto sotto forma di spezzoni.</p>
<ul>
<li>Lo spazio di memoria totale sarebbe sufficiente per soddisfare una richiesta, <strong>ma non è contiguo</strong>.</li>
<li>→ non si sfrutta a pieno la quantità di memoria totale a disposizione.</li>
</ul>
<p>Dualmente gli schemi a partizione di dimensione fissa soffrono del problema della frammentazione interna.</p>
<p><strong>Frammentazione interna</strong>: è un concetto relativo al singolo segmento, in particolare è legato alla dimensione di questo.</p>
<p>Se i segmenti hanno una dimensione fissa, non è detto che l’immagine di un processo sia un multiplo di questa dimensione. Quindi tale immagine potrebbe occupare un numero di segmenti, ma non tutte le word di questi segmenti avranno un significato.</p>
<p>Ovvero siamo sprecando una porzione dell’ultimo segmento in cui è contenuta l’immagine del processo.</p>
<p align="center"><img src="images/frammentazione_interna.png" width="550"></p>

<h2 id="paginazione"><a class="header" href="#paginazione">Paginazione</a></h2>
<p>La segmentazione oggi non viene più utilizzata.</p>
<p>Invece viene utilizzata la paginazione perché permette di eliminare un enorme problema: la frammentazione esterna.</p>
<p>Ovviamente non è perfetto come approccio infatti anche questo introduce un problema, quello di frammentazione interna. → perdo mediamente per ogni pagina una quantità di memoria pari alla metà della dimensione della pagina stessa.</p>
<p><strong>Paginazione</strong>:</p>
<ul>
<li>
<p>tecnica di allocazione <strong>non contigua</strong> → se fosse contigua la paginazione non avrebbe senso;</p>
</li>
<li>
<p>lo spazio virtuale è diviso in <strong>blocchi di dimensione fissa</strong>;</p>
</li>
<li>
<p>evita la frammentazione esterna;</p>
</li>
<li>
<p>introduce la frammentazione interna.</p>
<p>A causa del fatto che lo spazio virtuale è suddiviso e quindi caricato in memoria fisica all’interno di blocchi di dimensione <strong>fissa</strong>.</p>
</li>
</ul>
<p align="center"><img src="images/associazione_pag_vir_fis.png" width="500"></p>

<ul>
<li>La <strong>tabella delle pagine</strong> è salvata in RAM e come per la segmentazione l’<em>entry point</em> è memorizzato nel PCB di ogni processo.</li>
<li>Ogni processo ha la propria tabella delle pagine.</li>
</ul>
<p>Come detto questo approccio è soggetto alla frammentazione interna.</p>
<p align="center"><img src="images/frammentazione_int.png" width="500"></p>

<ul>
<li>La pagina associata all’ultima pagina della memoria virtuale non è completamente utilizzata.<br>→ spreco della memoria, perché non è possibile più utilizzarla fino a quando non viene deallocata.</li>
</ul>
<p>Cosa accade nel momento in cui si verifica una frammentazione interna:</p>
<ul>
<li>spazio di memoria perso per un blocco assegnato ma non utilizzato a pieno</li>
<li>si verifica se la dimensione del processo non è un multiplo esatto della dimensione dei blocchi</li>
</ul>
<p>Questo fenomeno è tanto <strong>più trascurabile</strong> quanto <strong>più piccola è assegnata la dimensione</strong> di ogni pagina.</p>
<blockquote>
<p>Tipicamente, la <strong>dimensione di pagina</strong> è una potenza di 2, compresa tra 512 byte e 16 MB.</p>
</blockquote>
<h3 id="traduzione-degli-indirizzi"><a class="header" href="#traduzione-degli-indirizzi">Traduzione degli indirizzi</a></h3>
<p>Essendo l’allocazione non contigua è necessario memorizzare ogni pagina virtuale in che posizione della memoria fisica si trova.</p>
<p>Nel codice, quindi, si utilizzano indirizzi virtuali che devono essere <strong>tradotti dall’MMU</strong> in indirizzi fisici a run-time.</p>
<p>Questo hardware è necessario perché nell’approccio di allocazione <strong>non contigua non si conosce a priori dove sarà rilocato il codice</strong>.<br>→ dobbiamo sempre tener conto che se parliamo di paginazione allora stiamo parlando di rilocazione non contigua, altrimenti la paginazione non avrebbe senso.</p>
<p>Quindi quando l’architettura utilizza l’approccio di paginazione si tutti i programmi utilizzano indirizzi virtuali.</p>
<p>La paginazione, inoltre, non è solo una tecnica di allocazione non contigua, ma anche una tecnica per la <strong>gestione della memoria virtuale</strong>. In altre parole, la paginazione permette di creare uno spazio virtuale più grande della memoria fisica, se la gestione del caricamento delle pagine è della tipologia: <strong>a domanda</strong>.</p>
<p>Un indirizzo virtuale contiene la <strong>coppia</strong>:</p>
<ul>
<li><strong>numero di pagina (p)</strong>:<br>identifica una pagina nella memoria fisica → nel contesto di un processo.</li>
<li><strong>scostamento di pagina(d)</strong>:<br>indica la posizione dell’indirizzo all’interno della pagina.</li>
</ul>
<p><strong>A differenza della segmentazione</strong>, non sono due valori separati, ma sono contenuti entrambi in un <strong>unico valore</strong>.<br>→ Nel constesto della CPU, ovvero questa vede un unico indirizzo le cui informazioni non le tratta separatamente.</p>
<p>ESEMPIO: indirizzo virtuale a <strong>16bit</strong>: <code>0x0803</code></p>
<p align="center"><img src="images/indirizzo_paginazione.png" width="470"></p>

<p>Quindi l’indirizzo viene diviso in due campi ognuno dei quali porta con se un’informazione.</p>
<p>Vediamo come avviene la traduzione con l’utlizzo dell’MMU sulla <em>page table</em>.</p>
<p align="center"><img src="images/traduzione_pag.png" width="500"></p>

<p>L’MMU valuta in che posizione si trova l’indirizzo base della pagina identificata da <code>p</code> e utilizza tale indirizzo <code>f</code> sommato all’offset <code>d</code> per ottenere la traduzione in indirizzo fisico.</p>
<p>Ovviamente saranno presenti condizioni che bloccano i casi in cui si eccede dalla tabella delle pagine con <code>p</code>.</p>
<h3 id="tabella-delle-pagine"><a class="header" href="#tabella-delle-pagine">Tabella delle pagine</a></h3>
<p>La tabella delle pagine ha una riga per <strong>ogni pagina virtuale</strong> del <strong>processo</strong>.</p>
<p>All’interno di questa riga sono contenuti:</p>
<ul>
<li>indice della <strong>pagina fisica</strong>,</li>
<li><strong>bit di gestione</strong> (permessi di accesso, etc.).</li>
</ul>
<p>Ovviamente quando si tenta di operare su una pagina l’MMU verifica che il programma non violi i permessi presenti su tale.<br>→ in caso di violazione solleva un <strong>page fault</strong>.</p>
<p align="center"><img src="images/permessi_page_table.png" width="500"></p>

<p>La tabella delle pagine è in <strong>memoria principale</strong>.<br>La MMU usa 2 registri utilizzarla:</p>
<ul>
<li><strong>PTBR</strong> (Page-Table Base Register):
indirizzo fisico della tabella delle pagine in memoria fisica.</li>
<li><strong>PTLR</strong> (Page-Table Length Register):<br>dimensione della tabella delle pagine.</li>
</ul>
<p>Questi due valori sono contenuti all’interno del PCB di ogni processo e vengono caricati in tali registri ogni volta che avviene un <strong>contex switch</strong>.</p>
<p align="center"><img src="images/PTBR_PTLR.png" width="480"></p>

<h3 id="architettura-di-paginazione-con-tlb"><a class="header" href="#architettura-di-paginazione-con-tlb">architettura di paginazione con TLB</a></h3>
<p>Per accedere ad ogni singolo dato nella memoria quindi servono <strong>due accessi</strong>.</p>
<ol>
<li>per <strong>leggere la tabella delle pagine</strong></li>
<li>per <strong>accedere al dato/istruzione</strong> vero e proprio</li>
</ol>
<p>Questo provoca un <strong>rallentamento</strong> degli accessi a memoria.</p>
<p>Per <strong>migliorare l’efficienza</strong>, si usa una <strong>cache associativa</strong> detta <strong>TLB</strong> (Translation Look-aside Buffer) che si trova all’interno dell’MMU.</p>
<p>La ricerca di un valore in tale cache associativa ha complessità O(1) → costante.</p>
<!-- @todo da chiedere perché è lineare -->
<p align="center"><img src="images/TLB.png" width="600"></p>

<ul>
<li>
<p>Si possono verificare due situaizioni:</p>
<ul>
<li>L’accesso alla TLB produce un cache hit, quindi subito ho l’entry point della pagina in memoria fisica, tale operazione richiede nanosecondi.</li>
<li>L’accesso alla TLB produce un cache miss, quindi la ricerca passa sulla tabella delle pagine, tale operazione richiede decine di nanosecondi.</li>
</ul>
<p>In ogni caso dovrò fare più di un accesso per ottenere il dato/istruzione nella memoria fisica.</p>
</li>
</ul>
<h4 id="tempo-effettivo-di-accesso"><a class="header" href="#tempo-effettivo-di-accesso">Tempo effettivo di accesso</a></h4>
<p><strong>Tasso di successo</strong> (hit ratio, <strong>ɑ</strong>): percentuale di volte che un numero di pagina virtuale si trova nel TLB.</p>
<p>Supponiamo che:</p>
<ul>
<li>Lookup associativo = <strong>ε</strong> unità di tempo</li>
<li>Un accesso alla memoria = <strong>ĸ</strong> unità di tempo</li>
</ul>
<p>Allora il <strong>tempo effettivo d’accesso</strong> (<em>effective access time</em>):</p>
<p>$$EAT = (ĸ + ε)ɑ + (2ĸ + ε)(1-ɑ) = (2-ɑ)ĸ +ε$$</p>
<p>Dove la prima parte indica il tempo in caso di successo mentre la seconda indica il tempo in caso di insuccesso.</p>
<p>Questo <em>EAT</em> è il <strong>tempo medio che un sistema impiega per accedere alla memoria</strong>, tendendo conto sia degli <strong>hit cache</strong> che dei <strong>miss cache</strong>.</p>
<p>(supponendo che la pagina sia effettivamente presente in memoria fisica, ovvero che non debba esser caricata dalla memoria di massa)</p>
<h4 id="dimensione-della-tabella-delle-pagine"><a class="header" href="#dimensione-della-tabella-delle-pagine">Dimensione della tabella delle pagine</a></h4>
<p>La scelta della dimensione della pagina influenza molto l’efficienza, per questo è necessario che si trovi un gusto compromesso per sistemi general porpose.</p>
<p>Supponendo di avere un sistema che valuta indirizzi a <code>32bit</code>.
→ Lo spazio totale di indirizzamento:  \(2^{32} = 4\)GB.</p>
<p>Usando pagine di \(1\)KB (\(2^{10}\)):</p>
<ul>
<li><strong>dimensione</strong> della tabella: \(2^{22} = 4\)MB → ⚠️​</li>
<li><strong>frammentazione interna</strong> media: \(\frac{2^{10}}{2} = 0.5\)KB → 👍🏿</li>
</ul>
<p>Usando pagine di \(64\)KB (\(2^{16}\)):</p>
<ul>
<li><strong>dimensione</strong> della tabella: \(2^{16} = 64\)KB → 👍🏿</li>
<li><strong>frammentazione interna</strong> media: \(\frac{2^{10}}{2} = 0.5\)KB → ⚠️​</li>
</ul>
<p>Come si può notare la scelta di una dimensione o del numero di pagine influenza l’altra grandezza.</p>
<p>→ bisogna scegliere una <strong>dimensione di pagina</strong> che abbia un buon <strong>compromesso</strong> tra i due valori.<br>→ Il compromesso è tra <strong>frammentazione e performance</strong>. Perché aumentato il numero di pagine riduco la frammentazione ma diminuisco le performance poiché il SO deve gestire un grande numero di pagine; invece diminuendo il numero di pagine aumento la frammentazione interna media per ogni pagina.</p>
<h3 id="validità-delle-pagine-virtuali"><a class="header" href="#validità-delle-pagine-virtuali">Validità delle pagine virtuali</a></h3>
<p>Raramente un processo usa tutto il suo spazio di indirizzamento virtuale.<br>→ quantità di memoria usata tipicamente da una applicazione desktop si aggira intorno: ~\(100\)MB. (single process)</p>
<p>Lo spazio virtuale che un processo potenzialmente può utilizzare è pari all’intero spazio di indirizzamento: se ho <code>16bit</code> per indirizzo → \(4\)GB</p>
<p align="center"><img src="images/spazio_processi.png" width="300"></p>

<p>In realtà alcune delle pagine all’interno dello spazio virtuale allocato, non sono veramente utilizzate.</p>
<p>→ tra i bit di controllo possiamo aggiungere un <em>validity bit</em>.</p>
<p>Quindi il SO può marcare le pagine <strong>virtuali in uso</strong> usando tale bit nella tabella delle pagine.</p>
<blockquote>
<p>il bit di validità so riferisce alle pagine virtuali → infatti ogni entry point della tabella delle pagine identifica una pagina virtuale.</p>
</blockquote>
<p>Il bit di validità viene attivato nel momento in cui la pagina è <strong>allocata</strong> dal processo (es. tramite <code>malloc()</code>).</p>
<p align="center"><img src="images/bit_validita.png" width="400"></p>

<p>Supponendo che all’interno della page table sono contenute tutte le possibili pagine che un processo può utilizzare. → copre l’intero spazio di indirizzamento.</p>
<p>Allora potremmo avere due casistiche nel momenti in cui un processo genera un indirizzo virtuale la cui parte che <strong>identifica il numero</strong> di pagina non è associato a nessun frame fisico.<br>Le cause di questa situazione sono dovute al fatto che:</p>
<ul>
<li>la pagina potrebbe esser stata swappata V = 0;</li>
<li>l’indirizzo virtuale non appartiene ad alcuna regione di memoria valida del processo.</li>
</ul>
<p align="center"><img src="images/page_fault.png" width="500"></p>

<p>La MMU genera quindi genera una <strong>exception</strong> (page fault).</p>
<ul>
<li>Il SO non termina subito il processo se la pagina appartiene al suo spazio di indirizzamento, infatti viene eseguita l’ISR per gestire il page fault che cerca di allocarla dalla memoria secondaria.
<ul>
<li>Il SO termina il processo solo le il risultato del page fault handler non mappa la pagina virtuale in una pagina fisica → perché non è stata trovata nella memoria secondaria.</li>
<li>Oppure se l’operazione che il processo tenta di fare su tale area non è valida secondo i permessi descritti su questa.</li>
</ul>
</li>
</ul>
<p>Cosa accede durante un <strong>contex switch</strong></p>
<p align="center"><img src="images/contex_switch.png" width="500"></p>

<ul>
<li>La TLB viene popolata a <strong>run-time</strong> → inizialmente saranno presenti solo page fault che porsano al SO a ricaricare le pagine in memoria principale.</li>
</ul>
<p>Oltre al bit di validità è presente un ulteriore bit di controllo: il <em>dirty bit</em>.</p>
<p>Questo dirty bit è legato al fatto che la pagina <strong>è stata scritta</strong> durante la sua permanenza in memoria fisica.</p>
<p>Quando un processo <strong>scrive</strong> in una pagina fisica, la MMU setta automaticamente il dirty bit a \(1\).<br>Questo bit indica che il contenuto della pagina <strong>non coincide più</strong> con la copia originale presente su disco. → tale informazione ha un implicazione durante lo <strong>swap-out</strong>.</p>
<ul>
<li>Se il dirty bit = 1, significa che la oagina contiene modifiche <strong>che devono essere salvate nello swap</strong>, altrimenti andrebbero perse.</li>
<li>Se il dirty bit = 0, significa che la pagina <strong>non è stata modificata</strong> e che <strong>esiste già una copia valida</strong> della pagina su disco (es. nell’eseguibile del processo, è stata già salvata precedentemente).</li>
</ul>
<p>Per il meccanismo di coerenza caching, si deve garantire la coerenza tra memoria grande e memoria piccola.</p>
<h3 id="struttura-della-tabella-delle-pagine"><a class="header" href="#struttura-della-tabella-delle-pagine">Struttura della tabella delle pagine</a></h3>
<p>Bisogna capire quale struttura sia più adatta a contenere la tabella delle pagine al fine di risolvere diverse problematiche:</p>
<p><strong>Problemi</strong>: le tabelle delle pagine:</p>
<ul>
<li>hanno grosse dimensioni</li>
<li>sono numerose (una per ogni processo)</li>
<li>sono “sparse” (poche pagine valide)</li>
</ul>
<p><strong>Soluzioni</strong>: per ogni problema</p>
<ul>
<li>Paginazione gerarchica → evita il problema della <strong>grandezza</strong></li>
<li>Tabella delle pagine basata su hash → evita il problema della <strong>numerosità</strong></li>
<li>Tabella delle pagine invertita → non si usa più (ideale per vecchi sistemi operativi)<br>→ per evitare il problema della <strong>sparsità</strong></li>
</ul>
<h4 id="paginazione-gerarchica"><a class="header" href="#paginazione-gerarchica">Paginazione gerarchica</a></h4>
<p>Suddivisione della tabella delle pagine in parti più piccole, secondo una <strong>organizzazione <strong>gerarchica</strong></strong>.</p>
<ul>
<li>La MMU divide l’indirizzo di pagina in più parti (\(p_1,p_2)\), tante quanti sono i livelli di gerarchia.</li>
<li>Nella tabella di primo libello, trova l’indirizzo della tabella di secondo livello, e così via.</li>
</ul>
<hr>
<blockquote>
<p>Nota: la MMU <strong>impiega più tempo per attraversare la tabella gerarchica</strong> (aumentano i tempi di accesso).</p>
</blockquote>
<p>Vediamo il motivo di questo tempo aggiuntivo per attraversare la memoria: (2 livelli di gerarchia)</p>
<p>indirizzo virtuale: \((p_1, p_2, offset)\).</p>
<p>Il flusso sarebbe:</p>
<ol>
<li>La MMU accede alla tabella di primo livello e usando \(p_1\) (<strong>accesso a memoria</strong>) ottiene l’indirizzo base della tabella di secondo livello.</li>
<li>La MMU accede alla tabella di secondo livello e usando \(p_2\) (<strong>accesso a memoria</strong>) ottiene il numero di frame corrispondente.</li>
<li>Infine, la MMU accede alla memoria principale nel frame trovaro e utilizza \(offset\) (<strong>accesso a memoria</strong>) per recuperare la casella desiderata.</li>
</ol>
<p>Il motivo dell’aumento del tempo per attraversare la tabella è che la MMU ha bisogno di fare molti <strong>più accessi a memoria fisica</strong> per tradurre un <strong>singolo</strong> <strong>indirizzo</strong> <strong>virtuale</strong>.</p>
<p>Nel caso di paginazione semplice (ad un livello) il numero di accessi totali per operare la traduzione di un indirizzo virtuale è pari a 2.</p>
<ol>
<li>Accesso alla page table</li>
<li>accesso alla memoria fisica</li>
</ol>
<hr>
<p align="center"><img src="images/tabella_gerarchica.png" width="500"></p>

<ul>
<li>Con l’utilizzo di questa struttura si è risolto il problema della grandezza di una tabella delle pagine.</li>
</ul>
<p align="center"><img src="images/struttura_gerarchica.png" width="600"></p>

<ul>
<li>Linux utilizza 4 livelli gerarchici per la tabella delle pagine di ogni processo.</li>
<li>Questa struttura serve <strong>per evitare di allocare una struttura grande quanto tutto lo spazio indirizzabile dal processo</strong>.<br>→ sono presenti delle porzioni (tabelle intermedie) per cui è possibile evitare l’allocazione perché vuote</li>
</ul>
<p>Le singole tabelle sono più piccole rispetto alla tabella non gerarchica.</p>
<p>ESEMPIO DI PAGINAZIONE A DUE LIVELLI:</p>
<p>Nella paginazione gerarchica, il “numero di pagina” nell’indirizzo virtuale viene <strong>a sua volta suddiviso in più parti</strong> (tante quante sono i livelli di gerarchia).</p>
<p align="center"><img src="images/esempio_gerarchia.png" width="400"></p>

<h3 id="tabelle-delle-pagine-basate-su-hash"><a class="header" href="#tabelle-delle-pagine-basate-su-hash">Tabelle delle pagine basate su hash</a></h3>
<p>Le righe della tabella delle pagine sono organizzate utilizzando una <strong>lista concatenata (linked list)</strong>.</p>
<ul>
<li>Si memorizzano esclusivamente le righe per le pagine valide.</li>
<li>Otteniamo quindi un ulteriore <strong>risparmio di memoria</strong>, ma ciò <strong>rallenta la ricerca</strong> (occorre scandire la linked list, ricerca basata sul contenuto).</li>
</ul>
<p>Per ottimizzare i tempi di ricerca, si dividono le righe su <strong>tante liste concatenate</strong> di <strong>piccole dimensioni</strong>.</p>
<ul>
<li>Una funzione di hash è applicata al numero della pagina virtuale.</li>
<li>Gli elementi (entry) con lo <strong>stesso valore della funzione di hash</strong> sono <strong>collocati</strong> nella <strong>stessa</strong> <strong>lista</strong> <strong>concatenata</strong>.</li>
</ul>
<p align="center"><img src="images/hash_page_table.png" width="500"></p>

<ul>
<li>Dopo l’applicazione della funzione di hash sul numero di pagina, che si trovava nell’indirizzo virtuale, si individua una delle \(M\) pagine (liste concatenate).</li>
<li>Dove \(M &lt; N\) perché la funzione di hash procude delle collisioni (\(N\) è il numero di pagine totali).</li>
<li>Dopo aver individuato la lista concatenata si cerca all’interno di questa il numero di pagina che identifica la pagina fisica in cui è mappata la pagina virtuale.</li>
</ul>
<p>Ovviamente in questo approccio la lunghezza delle liste concatenate è contenuto rispetto al caso in cui abbiamo solo una lista concatenata di tutte le pagine associate ad un processo.</p>
<h3 id="tabella-delle-pagine-invertita"><a class="header" href="#tabella-delle-pagine-invertita">Tabella delle pagine invertita</a></h3>
<p>Negli schemi precedenti esiste <strong>una tabella distinta per ogni processo</strong>.</p>
<p>In questo approccio, <strong>tabella delle pagine invertita</strong>, si hanno queste caratteristiche:</p>
<ul>
<li><strong>Una</strong> sola tabella delle pagine <strong>comune a tutti i processi</strong>.</li>
<li>Questa tabella ha un elemento per <strong>ogni pagina fisica</strong>.</li>
<li>Ogni elemento contiene l’indirizzo <strong>virtuale</strong> della pagina memorizzata <strong>in quella locazione fisica</strong>, con informazioni sul processo detentore della pagina.</li>
</ul>
<p align="center"><img src="images/tabella_delle_pagine_invertita.png" width="500"></p>

<p>Una sola è la tabella delle pagine → globale.</p>
<p>Il numero di righe è pari al numero di pagine fisiche (invece che virtuali).</p>
<ul>
<li>
<p>Ogni entry della tabella contiene il PID, del processo che possiede la pagina fisica, e l’indirizzo virtuale di tale pagina.</p>
</li>
<li>
<p>Una volta trovata la riga corrispondente si valuta l’offset rispetto l’indirizzo di base della tabella delle pagine invertita.<br>Tale offset corrisponde alla prima parte dell’indirizzo fisico della pagina in memoria fisica.</p>
<p>Infatti l’ultima operazione è quella di inserire l’offset nella parte dell’indirizzo virtuale in cui è presente il numero di pagina e il PID.</p>
</li>
</ul>
<p>In questo approccio risparmiamo la numerosità delle pagine, oltre al fatto che queste non sono più sparse nella memoria fisica. → si può sfruttare il principio di località.</p>
<h3 id="segmentazione-paginata"><a class="header" href="#segmentazione-paginata">Segmentazione paginata</a></h3>
<p>Utilizzata in Linux.</p>
<p align="center"><img src="images/segmentazione_paginata.png" width="500"></p>

<p>In questa soluzione si utilizza principalmente una paginazione con il supporto hardware.</p>
<p>Ma a livello software si sfruttano tutti i vantaggi della segmentazione:</p>
<ul>
<li>condivisione dei segmenti</li>
<li>granularità fine per l’assegnazione dei permessi → protezione delle aree di memoria</li>
<li>dimensione variabile dei segmenti</li>
</ul>
<p>Questa tabella dei segmenti viene risolta in software, mentre la tabella delle pagine viene risolta in hardware sempre dall’MMU.</p>
<p>La <strong>tabella dei segmenti</strong> è unica <strong>per ogni processo</strong>.<br>La <strong>tabella delle pagine</strong> è unica per <strong>ogni segmento del processo</strong>.</p>
<p>Quindi per ogni segmento avremo una tabella delle pagine in cui sono mappate le pagine virtuali corrispondenti a tale segmento in pagine fisiche.</p>
<p>Quando il processore utilizza un indirizzo virtuale <code>x = &lt;sg, sc&gt;</code>, <code>sg</code> identifica un segmento all’interno della tabella dei segmenti.<br>Una volta ottenuto l’indirizzo base della tabella delle pagine per il segmento identificato precedentemente, viene utilizzata l’altra parte dell’indirizzo virtuale <code>sc</code> per identificare la pagine fisica.</p>
<p>→ si utilizza <code>sc</code> come offset rispetto l’indirizzo base della tabella delle pagine.</p>
<p>A questo punto, ottenuta l’indirizzo base della pagina fisica, si somma a questo l’offset <code>of</code> per ottenere l’indirizzo fisico a cui il processo fa riferimento.</p>
<p>Ovviamente durante tutto questo processo si devono verificare le condizione che non causino inconsistenze tra i processi, come le condizione di limite con <code>STBL</code> e <code>PTLR</code>.</p>
<blockquote>
<p>Quindi nella tabella dei segmenti individuo l’<em>entry point</em> che fa riferimento alla tabella delle pagine per quel segmento.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="deadlock.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="gestione_della_memoria_in_linux.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="deadlock.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="gestione_della_memoria_in_linux.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
